{"version":3,"file":"tanstack-CPlEqbpz.js","sources":["../../node_modules/@tanstack/virtual-core/dist/esm/utils.js","../../node_modules/@tanstack/virtual-core/dist/esm/index.js"],"sourcesContent":["function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1.01;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport {\n  approxEqual,\n  debounce,\n  memo,\n  notUndefined\n};\n//# sourceMappingURL=utils.js.map\n","import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = memo(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      let attempts = 0;\n      const maxAttempts = 10;\n      const tryScroll = (currentAlign) => {\n        if (!this.targetWindow) return;\n        const offsetInfo = this.getOffsetForIndex(index, currentAlign);\n        if (!offsetInfo) {\n          console.warn(\"Failed to get offset for index:\", index);\n          return;\n        }\n        const [offset, align] = offsetInfo;\n        this._scrollToOffset(offset, { adjustments: void 0, behavior });\n        this.targetWindow.requestAnimationFrame(() => {\n          const currentOffset = this.getScrollOffset();\n          const afterInfo = this.getOffsetForIndex(index, align);\n          if (!afterInfo) {\n            console.warn(\"Failed to get offset for index:\", index);\n            return;\n          }\n          if (!approxEqual(afterInfo[0], currentOffset)) {\n            scheduleRetry(align);\n          }\n        });\n      };\n      const scheduleRetry = (align) => {\n        if (!this.targetWindow) return;\n        attempts++;\n        if (attempts < maxAttempts) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"Schedule retry\", attempts, maxAttempts);\n          }\n          this.targetWindow.requestAnimationFrame(() => tryScroll(align));\n        } else {\n          console.warn(\n            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`\n          );\n        }\n      };\n      tryScroll(initialAlign);\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  debounce,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n"],"names":["memo","getDeps","fn","opts","deps","result","memoizedFunction","_a","_b","_c","_d","depTime","newDeps","dep","index","resultTime","depEndTime","resultEndTime","resultFpsPercentage","pad","str","num","notUndefined","value","msg","approxEqual","a","b","debounce","targetWindow","ms","timeoutId","args","getRect","element","offsetWidth","offsetHeight","defaultKeyExtractor","defaultRangeExtractor","range","start","end","arr","i","observeElementRect","instance","cb","handler","rect","width","height","observer","entries","run","entry","box","addEventListenerOptions","supportsScrollend","observeElementOffset","offset","fallback","createHandler","isScrolling","horizontal","isRtl","endHandler","registerScrollendEvent","measureElement","elementScroll","adjustments","behavior","toOffset","Virtualizer","_ro","get","target","opts2","key","sync","d","scrollElement","cached","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","previousFurthestMeasurement","count","paddingStart","scrollMargin","getItemKey","enabled","itemSizeCache","item","min","furthestMeasurement","measuredSize","size","lane","outerSize","scrollOffset","lanes","calculateRange","startIndex","endIndex","rangeExtractor","overscan","node","attributeName","indexStr","prevNode","itemSize","delta","indexes","virtualItems","k","len","findNearestBinarySearch","align","maxOffset","initialAlign","attempts","maxAttempts","tryScroll","currentAlign","offsetInfo","currentOffset","afterInfo","scheduleRetry","endByLane","val","low","high","getCurrentValue","middle","currentValue","lastIndex","getOffset","endPerLane","pos","startPerLane"],"mappings":"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","x_google_ignoreList":[0,1]}